"""Punch Kicker bootstrap helper classes"""

import sys, os, json, subprocess, requests, datetime, re, shutil, pathlib
from urllib.parse import urlparse
from time import ctime

_marker = object()

class Environment(object):
    _defaults = {
        "KICK_FILES_DIR": "/run/punchkicker/files",
        "CLOUD_LIB": "/var/lib/cloud"
    }

    def __init__(self):
        self._node = None
        self.environ = e = os.environ.copy()
        for k, v in self._defaults.items():
            e.setdefault(k, v)

    @property
    def node(self):
        if self._node is None:
            self._node = Node(self)
        return self._node

    def get(self, key, default=None):
        return self.environ.get(key, default)

    def dict(self):
        return self.environ.copy()

    def path(self, path):
        return path.format(**self.environ)

    def apk_add(self, *packages, repo=None, indent=8):
        repotext = ""
        repoargs = []
        if repo is not None:
            repotext = " [" + repo + "]"
            repoargs = ["-X", repo]

        print(" " * indent + "adding apk package(s) " + ",".join(packages) + repotext+ ":")

        self.run_with_print(["apk", "add"] + repoargs + list(packages), indent=indent)

    def service_add(self, service):
        print("    Enabling service %s:" % service)
        self.run_with_print(["rc-update", "add", service])

    def service_start(self, service):
        print("    Starting service %s:" % service)
        self.run_with_print(["rc-service", service, "start"])

    def pip_install(self, package):
        print("    adding pip3 package %s:" % package)
        self.run_with_print(["pip3", "install", package])

    def run_with_print(self, cmd, indent=8):
        sys.stdout.flush()
        try:
            out = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode('utf8').strip()
        except subprocess.CalledProcessError as e:
            print(self.indent_output(e.output, indent))
            raise
        if out:
            print(self.indent_output(out, indent))
        sys.stdout.flush()
        return out

    def run_get_json(self, cmd):
        return json.loads(subprocess.check_output(cmd))

    def indent_output(self, s, indent=8):
        sindent = " " * indent
        return "\n".join([sindent + s for s in s.split("\n")])

    def mkdir_p(self, path):
        try:
            pathlib.Path(self.path(path)).mkdir(parents=True, exist_ok=True)
        except FileExistsError:
            pass

    def download_url(self, url, filename):
        url = url.format(**self.environ)
        parsed = urlparse(url)
        if parsed.scheme == "s3":
            import boto3
            s3 = boto3.client("s3")
            s3.download_file(parsed.hostname, parsed.path.lstrip("/"), filename)
        else:
            auth = None
            if parsed.username or parsed.password:
                auth = (parsed.username or "", parsed.password or "")

            r = requests.get(url, auth=auth)
            with open(filename, "wb") as f:
                f.write(r.content)

    def ts_iso8601(self):
        now = datetime.datetime.utcnow()
        ts = now.replace(tzinfo=datetime.timezone.utc).isoformat()
        return ts.replace('+00:00', 'Z')

    def gen_comment(self):
        return "# Generated by punchkicker bootstrap|n# %s\n" % self.ts_iso8601()

    def resolvconf(self, nsaddrs, search=["node.consul"]):
        with open("/etc/resolv.conf", "w") as f:
            f.write(self.gen_comment())

            # Use up to 3 of the given nameservers
            for ip in nsaddrs:
                f.write("nameserver %s\n" % ip)
            f.write("search %s\n" % " ".join(search))

    def add_repo(self, repo_url, repo_file="/etc/apk/repositories"):
        changed = saw_repo = False
        new_file = []

        with open(repo_file, "r") as f:
            for line in f:
                if line.strip() == repo_url:
                    saw_repo = True

                new_file.append(line)

        if not saw_repo:
            new_file.append(repo_url + "\n")
            changed = True

        if changed:
            os.rename(repo_file, repo_file + ".bak")
            with open(repo_file, "w") as f:
                f.writelines(new_file)

        return changed

    def add_mount(self, mountpoint, source=None, label=None, type=None,
        opts="defaults", dump_freq=0, fsck_passno=0, filename="/etc/fstab"):

        if label is not None:
            source = "LABEL=%s" % label

        changed = False
        saw_mountpoint = False

        new_file = []
        new_fields = [source, mountpoint, type, opts, str(dump_freq), str(fsck_passno)]

        with open(filename, "r") as f:
            for line in f:
                if line.strip().startswith("#"):
                    new_file.append(line)
                else:
                    fields = line.strip().split()

                    if fields[0] == source or fields[1] == mountpoint:
                        saw_mountpoint = True
                        if fields == new_fields:
                            new_file.append(line)
                        else:
                            new_file.append(" ".join(new_fields) + "\n")
                            changed = True
                    else:
                        new_file.append(line)

        if not saw_mountpoint:
            new_file.append(" ".join(new_fields) + "\n")
            changed = True

        if changed:
            os.rename(filename, filename + ".bak")
            with open(filename, "w") as f:
                f.writelines(new_file)

        return changed

    def mount(self, path):
        if not os.path.ismount(path):
            self.run_with_print(["mount", path])
            return True
        else:
            return False

    def resource_file(self, srcfn, destpath, mode=None, user=None, group=None):
        srcpath = os.path.join(env.get("KICK_FILES_DIR"), srcfn)
        shutil.copy(srcpath, destpath)
        if mode is not None:
            os.chmod(destpath, mode)
        if user or group:
            shutil.chown(destpath, user, group)


env = Environment()

class Node(object):
    _tag_set_inheritance_order = ["instance_tags", "subnet_tags", "vpc_tags"]
    _non_inheritable_tags = {"Name"}

    _role_from_name_patterns = {
        "^leader[^a-z].*" : "leader",
        "^shell[^a-z].*" : "shell",
        "^worker[^a-z].*" : "worker",
        "^kcontrol[^a-z].*" : "kubical-control",
        "^kubical[^a-z].*" : "kubical-both",
        "^kworker[^a-z].*" : "kubical-worker",
    }

    _role_substs = [
        (re.compile(r, re.IGNORECASE), s) for r, s in _role_from_name_patterns.items()
    ]

    _implied_roles = {
        "leader" : {
            "vault-agent", "vault", "consul-server", "nomad-server", "unbound"
        },
        "shell" : {
            "dev-tools", "nfs-client", "efs-mounts", "k3s-bin", "kubical-admin"
        },
        "kubical-both" : {
            "kubical-control", "kubical-worker"
        },
        "kubical-control" : {
            "k3s-bin"
        },
        "kubical-worker" : {
            "k3s-bin"
        },
        "worker" : {
           "vault-agent", "consul-client", "nomad-client", "docker", "nfs-client"
        },
        "consul-client" : {
            "consul-bin",
        },
        "consul-server" : {
            "consul-bin",
        },
        "nomad-client" : {
            "nomad-bin",
        },
        "nomad-server" : {
            "nomad-bin",
        },
        "vault-agent" : {
            "vault-bin"
        },
        "vault" : {
            "vault-bin"
        },
    }

    def __init__(self, env=env):
        self.env = env
        self._roles = None
        self._conf_rules = None
        with open(os.path.join(env.get("CLOUD_VAR"), "node.json")) as f:
            self._data = json.load(f)

    def get(self, key, default=None):
        return self._data.get(key, default)

    def get_setting(self, var_name, tag_name, default=None):
        """
        Get the setting with the environment variable taking priority,
        then falling back to the named tag, and finally to the given default
        """

        val = self.env.get(var_name, _marker)
        if val is _marker:
            val = self.tag(tag_name, _marker)
        if val is _marker:
            val = default

        return val

    def cloud(self):
        return self.get("cloud", "baremetal")

    def raw_tag(self, key, default=None, tags_set="instance_tags"):
        if isinstance(tags_set, list):
            tags = tags_set
        else:
            tags = self.get(tags_set, [])

        for tag in tags:
            if tag.get("Key") == key:
                return tag.get("Value", default)

        return default

    def tag(self, key, default=None):
        tag_sets = self._tag_set_inheritance_order
        if key in self._non_inheritable_tags:
            tag_sets = tag_sets[:1]

        for tag_set in tag_sets:
            value = self.raw_tag(key, _marker, tag_set)
            if value is not _marker:
                return value

        return default

    def nameservers(self):
        """
        Get the configured nameserver IPs. The inherited tag
        nomadic-ns can be overridden by the variable
        NOMADIC_NS. Both are specificed as a comma-separated string.
        """
        ns = self.get_setting("NOMADIC_NS", "nomadic-ns")
        if ns is not None:
            ns = ns.split(",")
        return ns

    def dns_search(self):
        """
        Get the configured nameserver search path. The inherited tag
        nomadic-dns-search can be overridden by the variable
        NOMADIC_DNS_SEARCH. Both are specificed as a comma-separated string.
        """
        return self.get_setting(
            "NOMADIC_DNS_SEARCH", "nomadic-dns-search", "node.consul").split(",")

    def hostname(self):
        with open("/etc/hostname", "r") as f:
            return f.readline().strip()

    def primary_ip(self):
        """Return the local IPv4 of eth0"""
        data = self.env.run_get_json(["ip", "-j", "-f", "inet", "address", "show", "eth0"])
        return data[0]["addr_info"][0]["local"]

    @property
    def conf_rules(self):
        if self._conf_rules is None:
            self._conf_rules = self._compute_conf_rules()
        return self._conf_rules
        
    def _compute_conf_rules(self):
        conf_fn = env.path('{CLOUD_VAR}/conf.json')
        if os.path.exists(conf_fn):
            with open(conf_fn) as f:
                return json.load(f)
        else:
            return []

    def get_conf(self, key):
       return [s[key] for s in self.conf_rules if key in s]

    @property
    def roles(self):
        if self._roles is None:
            self._roles = self._compute_roles()
        return self._roles

    def _compute_roles(self):
        roles = set()
        main_role = self.get_setting("KICK_ROLE", "punchkicker-role")
        if main_role is None:
            hostname = self.hostname()
            for r, s in self._role_substs:
                if r.fullmatch(hostname):
                    main_role = r.sub(s, hostname)
                    break

        if main_role is not None:
            roles.add(main_role)

        add_roles = self.get_setting("KICK_ADD_ROLES", "punchkicker-add-roles")
        if add_roles is not None:
            roles.update(set(add_roles.split(",")))

        del_roles = self.get_setting("KICK_DEL_ROLES", "punchkicker-del-roles")
        del_roles = set(del_roles.split(",")) if del_roles is not None else set()

        role_implications = self._implied_roles.copy()
        for added_implications in self.get_conf("implied-roles"):
            for role, implied_roles in added_implications.items():
                role_implications[role] = set(implied_roles)

        last_roles = None
        while last_roles != roles:
            last_roles = roles.copy()
            implied_roles = set()
            for role in roles:
                implied_roles.update(role_implications.get(role, set()))

            roles.update(implied_roles)
            roles.difference_update(del_roles)

        roles.add("base")
        
        return roles

    _arch_map = {
        "x86_64" : "amd64",
        "aarch64" : "arm64"
    }

    @property
    def go_arch(self):
        return self._arch_map[os.uname().machine]

